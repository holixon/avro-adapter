package io.holixon.avro.adapter.common.converter

import io.holixon.avro.adapter.api.AvroAdapterApi.fromByteArray
import io.holixon.avro.adapter.api.AvroAdapterApi.toByteArray
import io.holixon.avro.adapter.api.AvroSingleObjectEncoded
import io.holixon.avro.adapter.api.SchemaResolver
import io.holixon.avro.adapter.api.converter.SpecificRecordToSingleObjectConverter
import io.holixon.avro.adapter.api.ext.ByteArrayExt.toHexString
import io.holixon.avro.adapter.common.AvroAdapterDefault
import org.apache.avro.specific.SpecificRecordBase
import org.apache.avro.util.ClassUtils

/**
 * Converts any instance derived from [SpecificRecordBase] (generated from avsc) to a [ByteArray] that follows the format specified
 * in the [avro specs](https://avro.apache.org/docs/current/spec.html#single_object_encoding).
 */
class DefaultSpecificRecordToSingleObjectConverter(
  private val schemaResolver: SchemaResolver
) : SpecificRecordToSingleObjectConverter {

  override fun <T : SpecificRecordBase> encode(data: T): AvroSingleObjectEncoded = data.toByteArray()

  @Suppress("UNCHECKED_CAST")
  override fun <T : SpecificRecordBase> decode(bytes: AvroSingleObjectEncoded): T {
    val schemaId = AvroAdapterDefault.SchemaIdAndPayload(bytes).schemaId

    val writerSchemaWithId = schemaResolver.apply(schemaId).orElseThrow { IllegalArgumentException("can not read ${bytes.toHexString()}") }

    // we have to assume that the namespace and name of the message payload did not change, so we try to load the class based on the canonical name
    // of the writer schema. This might lead to another (earlier or later) revision, but the canonical name should not have changed.
    val targetClass: Class<SpecificRecordBase> =  ClassUtils.forName(writerSchemaWithId.canonicalName) as Class<SpecificRecordBase>

    // then we use reflection to call the decoder function generated by avro and return the result
    return targetClass.fromByteArray(bytes) as T
  }
}
